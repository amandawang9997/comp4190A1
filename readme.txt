To run, simply execute any of the following .py files; 
backtrack.py,
backtrack_h1.py,
backtrack_h2.py,
backtrack_h3.py,
forward_checking.py,
forward_checking_h1.py,
forward_checking_h2.py,
forward_checking_h3.py,

and enter a puzzle in the following format;

#Start
6 6
1_11_2
1_0___
__2___
2__3_0
_13_10
1___00
#End

Features.

- We made the observation that, if you represent your constraints correctly, solutions, and only
solutions, occur at the maximum depth of the search tree. Using this, we never check if our puzzle is solved. Instead we check that all the cells have been assigned. This sped up the algorithms significantly.

- After every arc consistent update, we search through the unassigned nodes and, if they have only
one valid option left, we assign it without triggering an arc consistent update. We do not count this as
visiting a node. We consider this warrented as the arc consisitent update is where the vast majority of
the computation time is spent and so it would not make sense to consider this as the same as a regular
node assignment. This sped up the base forward_checking algorithm from 5s to 1s for a 16 by 16 puzzle.

- We treat constraints generated from lights--light constraints-- and constraints generated by walls
--wall constraints-- as two seperate contsraints graphs. Then our algorithm seeks to satisfy both
simultaneously.

- We represent our state as nested hash tables. We only search through a 2d array once, at the beginning,
when we are parsing the original 2d array into our nested hash table state. This can be seen in state.py
